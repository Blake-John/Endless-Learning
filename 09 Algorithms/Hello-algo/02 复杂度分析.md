![](imgs/Pasted%20image%2020231214151620.jpg)

# 2.1 算法效率评估

在算法的设计过程中，我们 **先后** 追求一下两个层面的目标：

1. **找到问题的解法** ：算法需要能够成功找到解法
2. **寻找最优解** ：同一个问题可能有许多种解法，我们希望找到 **尽可能高效的算法**

算法效率包括以下两个维度：

1. **时间效率** ：算法运行速度的快慢
2. **空间效率** ：算法占用内存空间的算法

简而言之，**我们的目标是设计“既快又省”的数据结构与算法**。而有效地评估算法效率至关重要，因为只有这样我们才能将各种算法进行对比，进而指导算法设计与优化过程。

效率评估方法主要分为两种：**实际测试**、**理论估算**。

## 2.1.1 实际测试

要对比两个算法的效率，最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性：

1. **难以排除测试环境的干扰**。不同硬件配置可能会得到不同的结果。
2. **展开完成测试非常耗费资源**。输入不同数据体量的时候算法效率可能不同。

## 2.1.2 理论估算

由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为「**渐近复杂度分析 asymptotic complexity analysis**」，简称「**复杂度分析**」。

复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。**它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势**。

- “时间和空间资源”分别对应「**时间复杂度 time complexity**」和「**空间复杂度 space complexity**」。
- “随着输入数据大小的增加”意味着复杂度反映了**算法运行效率与输入数据体量之间的关系**。
- “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间**增长的“快慢”**。

**复杂度分析克服了实际测试方法的弊端**，体现在以下两个方面。

- 它**独立于测试环境**，分析结果适用于所有运行平台。
- 它可以**体现不同数据量下的算法效率**，尤其是在大数据量下的算法性能。

# 2.2 迭代与递归

在算法中，**重复执行某个任务**是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。

## 2.2.1 迭代

「**迭代 iteration**」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

### 1. for 循环

`for` 循环是最常见的迭代形式之一，**适合在预先知道迭代次数时使用**。

此求和函数的操作数量与输入数据大小 $n$ 成正比，或者说成“线性关系”。实际上，**时间复杂度描述的就是这个“线性关系”**。相关内容将会在下一节中详细介绍。

### 2. while 循环

与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在 `while` 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。

**`while` 循环比 `for` 循环的自由度更高**。在 `while` 循环中，我们可以自由地设计条件变量的初始化和更新步骤。

```ad-example
例如，每轮循环 $i$ 更新两次，这种情况就不太方便使用 `for` 循环来实现
```
```Python
	def while_loop_ii(n: int) -> int:
		"""while 循环（两次更新）"""
		res = 0
		i = 1  # 初始化条件变量
		# 循环求和 1, 4, 10, ...
		while i <= n:
			res += i
			# 更新条件变量
			i += 1
			i *= 2
		return res
```

>但是请注意，不方便不意味着不能

总的来说，**`for` 循环的代码更加紧凑，`while` 循环更加灵活**，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。

### 3. 嵌套循环

我们可以再循环中再次进行一个循环，在这种情况下，函数的操作数量与 $n^{2}$ 成正比，或者说算法运行时间和输入数据大小 $n$ 成 ”**平方关系**“。

我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。

## 2.2.2 递归

「**递归 recursion**」是一种算法策略，通过**函数调用自身**来解决问题。它主要包含两个阶段。

1. **递** ： 程序 **不断深入地调用自身** ，一步步传入更小的或者更简化的参数，知道达到 ”**终止条件**“
2. **归** ： 触发”终止条件“后，程序从 **最深层的递归函数开始逐层返回** ，汇聚每一层的结果

而从实现的角度看，递归代码主要包含三个要素。

1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 $1 + 2 + \cdots + n$ 的计算：

```Python
	def recur(n: int) -> int:
	    """递归"""
	    # 终止条件
	    if n == 1:
	        return 1
	    # 递：递归调用
	    res = recur(n - 1)
	    # 归：返回结果
	    return n + res
```

虽然从计算角度看，迭代与递归可以得到相同的结果，**但它们代表了两种完全不同的思考和解决问题的范式**。

- **迭代**：“**自下而上**”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
- **递归**：“**自上而下**”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

以求和为例，设问题 $f(n) = 1 + 2 + \cdots + n$ :

- **迭代** ：在循环中模拟求和的过程， 从 $1$ 遍历到 $n$ ，每轮执行求和操作
- **递归** ：将问题分解为子问题 $f (n) = n + f (n - 1)$ ，不断地分解，直到基本情况 $f (1) = 1$ 

### 1. 调用栈

递归函数每次调用自身时，系统都会**为新开启的函数分配内存**，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。

如图 2-1 所示，在触发终止条件之前，同时存在 $n$ 个未返回的函数，**递归深度为** $\bf{n}$ 

![](imgs/Pasted%20image%2020231214154804.png)

在实际中，**编程语言所允许的递归深度通常是有限的** ，过深的递归可能导致 **栈溢出错误**

### 2. 尾递归

有趣的是，**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在**空间效率上与迭代相当**。这种情况被称为「**尾递归 tail recursion**」。

- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

仍以 $1 + 2 + \cdots + n$ 为例，我们可以将结果变量 `res` 设置为函数参数，从而实现尾递归

```Python
	def tail_recur (n, res) :
		"""尾递归"""
		# 终止条件
		if n == 0:
			return res;
		# 尾递归调用
		return tail_recur (n - 1, res + n)
```

尾递归的执行过程如图 2-2 所示。对比普通递归和尾递归，两者的求和操作的执行点是不同的。

- **普通递归**：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
- **尾递归**：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。

![](imgs/Pasted%20image%2020231214155355.png)

```ad-tip
请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。
```

### 3. 递归树

当处理与“**分治**”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“**斐波那契数列**”为例。

```ad-question
给定一个斐波那契数列 $0, 1, 1, 2, 3, 5, 8, 13, \cdots$ ，求该数列的第 $n$ 个数字。
```

```ad-hint
设斐波那契数列的第 $n$ 个数字为 $f (n)$ ，易得：
- 数列的前两个数字为 $f (1) = 0$ 和 $f(2) = 1$ 
- 数列中的每个数字是前两个数字的和，即 $f (n) = f (n - 1) + f (n - 2)$ 
```

按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码：

```Python
	def fib (n : int) -> int :
		"""斐波那契数列：递归"""
		# 终止条件
		if n == 1 or n == 2 :
			return n - 1
		# 递归调用
		res = fib (n - 1) + fib (n - 2)
		return res
```

观察以上代码，我们在函数内递归调用了两个函数，**这意味着从一个调用产生了两个调用分支**。如图 2-3 所示，这样不断递归调用下去，最终将产生一棵层数为 $n$ 的「**递归树 recursion tree**」。

![](imgs/Pasted%20image%2020231214160425.png)

从本质上看，递归体现了“**将问题分解为更小子问题**”的思维范式，这种分治策略至关重要。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理**链表**、**树**和**图**的相关问题，因为它们非常适合用**分治思想**进行分析。

## 2.2.3 二者对比

总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。

>表 2-1   迭代与递归特点对比

|          | 迭代                                   | 递归                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，**这种工作机制与栈的“先入后出”原则异曲同工**。

事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。

1. **递**：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。
2. **归**：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。

因此，**我们可以使用一个显式的栈来模拟调用栈的行为**，从而将递归转化为迭代形式：

```Python
	def for_loop_recur(n: int) -> int:
	    """使用迭代模拟递归"""
	    # 使用一个显式的栈来模拟系统调用栈
	    stack = []
	    res = 0
	    # 递：递归调用
	    for i in range(n, 0, -1):
	        # 通过“入栈操作”模拟“递”
	        stack.append(i)
	    # 归：返回结果
	    while stack:
	        # 通过“出栈操作”模拟“归”
	        res += stack.pop()
	    # res = 1+2+3+...+n
	    return res
```

```C++
	/* 使用迭代模拟递归 */
	int forLoopRecur(int n) {
	    // 使用一个显式的栈来模拟系统调用栈
	    stack<int> stack;
	    int res = 0;
	    // 递：递归调用
	    for (int i = n; i > 0; i--) {
	        // 通过“入栈操作”模拟“递”
	        stack.push(i);
	    }
	    // 归：返回结果
	    while (!stack.empty()) {
	        // 通过“出栈操作”模拟“归”
	        res += stack.top();
	        stack.pop();
	    }
	    // res = 1+2+3+...+n
	    return res;
}
```

观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。

- 转化后的代码可能更加难以理解，可读性更差。
- 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。

总之，**选择迭代还是递归取决于特定问题的性质**。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。

# 2.3 时间复杂度

运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？

1. **确定运行平台**，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。
2. **评估各种计算操作所需的运行时间**，例如加法操作 `+` 需要 $1\ ns$ ，乘法操作 `*` 需要 $10\ ns$ ，打印操作 `print()` 需要 $5\ ns$ 等。
3. **统计代码中所有的计算操作**，并将所有操作的执行时间求和，从而得到运行时间。

例如以下的代码，输入数据大小为 $n$ ：

```Python
	# 在某运行平台下
	def algorithm(n: int):
	    a = 2      # 1 ns
	    a = a + 1  # 1 ns
	    a = a * 2  # 10 ns
	    # 循环 n 次
	    for _ in range(n):  # 1 ns
	        print(0)        # 5 ns
```

则运行时间为 $(6n + 12)\ ns$ ：
$$1 + 1 + 10 + (1 + 5) * n = 6n + 12$$
但实际上，**统计算法的运行时间既不合理也不现实**。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。

## 2.3.1 统计时间增长趋势

时间复杂度分析统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。

“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 $n$  ，给定三个算法 `A`、`B` 和 `C` ：

```Python
	# 算法 A 的时间复杂度：常数阶
	def algorithm_A(n: int):
	    print(0)
	# 算法 B 的时间复杂度：线性阶
	def algorithm_B(n: int):
	    for _ in range(n):
	        print(0)
	# 算法 C 的时间复杂度：常数阶
	def algorithm_C(n: int):
	    for _ in range(1000000):
	        print(0)
```

图 2-4 展示了以上三个算法函数的时间复杂度。

![图 2-7   算法 A、B 和 C 的时间增长趋势](imgs/Pasted%20image%2020231214161832.png)

- 算法 `A` 只有 1 个打印操作，算法运行时间不随着 $n$ 增大而增长。我们称此算法的时间复杂度为“**常数阶**”。
- 算法 `B` 中的打印操作需要循环 $n$ 次，算法运行时间随着 $n$ 增大呈线性增长。此算法的时间复杂度被称为“**线性阶**”。
- 算法 `C` 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 $n$ 无关。因此 `C` 的时间复杂度和 `A` 相同，仍为“**常数阶**”。

相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？

- **时间复杂度能够有效评估算法效率**。例如，算法 `B` 的运行时间呈线性增长，在 $n>1$ 时比算法 `A` 更慢，在 $n>1000000$ 时比算法 `C` 更慢。事实上，只要输入数据大小 $n$ 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。
- **时间复杂度的推算方法更简便**。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。
- **时间复杂度也存在一定的局限性**。例如，尽管算法 `A` 和 `C` 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 `B` 的时间复杂度比 `C` 高，但在输入数据大小 $n$ 较小时，算法 `B` 明显优于算法 `C` 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。

## 2.3.2 函数渐进上界

给定一个输入大小为 $n$ 的函数：

```Python
	def algorithm (n : int) :
	a = 1     # +1
	a += 1    # +1
	a *= 2    # +1
	# 循环 n 次
	for i in range (n) :    # +1
		print (0)           # +1
	
```

设算法的操作数量是关于输入数据 $n$ 的函数，记为 $T (n)$ ，则以上函数的操作数量为：

$$T (n) = 3 + 2n$$

$T (n)$ 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶的。

我们将线性阶的时间复杂度记为 $O (n)$ 。这个数学符号称为「**大 $O$ 记号 big-$O$ notation**」，表示函数 $T (n)$ 的「**渐近上界 asymptotic upper bound**」。

```ad-note
若存在正整数 $c$ 和实数 $n_{0}$ ，使得对所有的 $n > n_{0}$ ，均有 $T (n) \leq c \cdot f (n)$ ，则可以认为 $f (n)$ 给出了 $T (n)$ 的一个渐进上界，记为 $T (n) = O (f (n))$ 。
```

如图 2-5 所示，计算渐近上界就是寻找一个函数 $f (n)$ ，使得当 $n$ 趋向于无穷大时， $T (n)$ 和 $f (n)$ 处于相同的增长级别，仅相差一个常数项 $c$ 的倍数。

![](imgs/Pasted%20image%2020231215195935.png)

## 2.3.3 推算方法

根据定义，确定 $f (n)$ 之后，我们便可以得到时间复杂度 $O (n)$ 。那么如何确定渐进上界 $f (n)$ 呢？总体分为两步：首先统计操作数量，然后判断渐进上界。

### 1. 统计操作数量

针对代码，逐行从上到下计算即可。然而，由于上述 $c \cdot f (n)$ 中的常数项 $c$ 可以取任意大小，**因此操作数量 $T (n)$ 中的各种系数、常数项都可以忽略**。根据此原则，可以总结出以下计数简化技巧。

1. **忽略 $T (n)$ 中的常数项** 。因为他们都与 $n$ 无关，所以对时间复杂度不产生影响。
2. **省略所有系数**。$2n$ ， $5n + 1$ 等都可以记为 $n$ ，系数同样对时间复杂度没有影响。
3. **循环嵌套时使用乘法**。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 `1.` 点和第 `2.` 点的技巧。

给定一个函数，我们可以用上述技巧来统计操作数量：

```Python
	def algorithm(n: int):
	    a = 1      # +0（技巧 1）
	    a = a + n  # +0（技巧 1）
	    # +n（技巧 2）
	    for i in range(5 * n + 1):
	        print(0)
	    # +n*n（技巧 3）
	    for i in range(2 * n):
	        for j in range(n + 1):
	            print(0)
```

### 2. 判断渐进上界

**时间复杂度由 $T (n)$ 中的最高阶项来决定** 。在 $n \rightarrow \infty$ 时，所有 **小量** 都可以忽略

表 2-2 展示了一些例子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。

>表 2-2 不同操作数对应的时间复杂度

| 操作数量 $T (n)$                | 时间复杂度 $O (f (n))$ |
| ------------------------------- | ---------------------- |
| $1000000$                       | $O (1)$                |
| $3n + 2$                        | $O (n)                 |
| $2n^{2} + 3n + 2$               | $O (n^{2})$            |
| $n^{3} + 1000000n^{2}$          | $O (n^{3})$            |
| $2^{n} + 10000000n^{1000000000}$ | $O(2^{n})$             |

## 2.3.4 常见类型

时间复杂度如图 2-6 所示：

$$O (1) < O (\log {n) < O (n) < O (n \log {n}) < O (n^{2})} < O (n!)$$

![](imgs/Pasted%20image%2020231215201503.png)

### 1. 常数阶

```Python
	def constant(n: int) -> int:
	    """常数阶"""
	    count = 0
	    size = 100000
	    for _ in range(size):
	        count += 1
	    return count
```

### 2. 线性阶

通常出现在 **单层循环中** 。

```Python
	def linear(n: int) -> int:
	    """线性阶"""
	    count = 0
	    for _ in range(n):
	        count += 1
	    return count
```

### 3. 平方阶

通常出现在 **嵌套循环中** ，内层外层的时间复杂度都为 $O (n)$ ，故总体时间复杂度为 $O (n^{2})$

```Python
	def quadratic(n: int) -> int:
	    """平方阶"""
	    count = 0
	    # 循环次数与数组长度成平方关系
	    for i in range(n):
	        for j in range(n):
	            count += 1
	    return count
```

以冒泡排序为例，外层循环执行 $n - 1$ 次，内层循环执行 $n - 1, n - 2, \cdots , 2, 1$ 次，平均为 $\frac {n}{2}$ 次，因此时间复杂度为 $O (\frac {(n - 1)n}{2}) = O (n^{2})$ 。

```Python
	def bubble_sort(nums: list[int]) -> int:
	    """平方阶（冒泡排序）"""
	    count = 0  # 计数器
	    # 外循环：未排序区间为 [0, i]
	    for i in range(len(nums) - 1, 0, -1):
	        # 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
	        for j in range(i):
	            if nums[j] > nums[j + 1]:
	                # 交换 nums[j] 与 nums[j + 1]
	                tmp: int = nums[j]
	                nums[j] = nums[j + 1]
	                nums[j + 1] = tmp
	                count += 3  # 元素交换包含 3 个单元操作
	    return count
```

```C++
	/* 平方阶（冒泡排序） */
	int bubbleSort(vector<int> &nums) {
	    int count = 0; // 计数器
	    // 外循环：未排序区间为 [0, i]
	    for (int i = nums.size() - 1; i > 0; i--) {
	        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
	        for (int j = 0; j < i; j++) {
	            if (nums[j] > nums[j + 1]) {
	                // 交换 nums[j] 与 nums[j + 1]
	                int tmp = nums[j];
	                nums[j] = nums[j + 1];
	                nums[j + 1] = tmp;
	                count += 3; // 元素交换包含 3 个单元操作
	            }
	        }
	    }
	    return count;
	}
```

### 4. 指数阶

生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 $1$ 个细胞，一轮后变为 $2$ 个，分裂 $n$ 轮后有 $2^{n}$ 个细胞。

```Python
	def exponential(n: int) -> int:
	    """指数阶（循环实现）"""
	    count = 0
	    base = 1
	    # 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)
	    for _ in range(n):
	        for _ in range(base):
	            count += 1
	        base *= 2
	    # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
	    return count
```

图 2-7 模拟了这种过程

![](imgs/Pasted%20image%2020231215202745.png)

在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过 $n$ 次分裂后停止：

```Python
	def exp_recur(n: int) -> int:
	    """指数阶（递归实现）"""
	    if n == 1:
	        return 1
	    return exp_recur(n - 1) + exp_recur(n - 1) + 1
```

指数阶增长非常迅速，在**穷举法（暴力搜索、回溯等）中比较常见** 。对于**数据规模较大**的问题，指数阶是**不可接受**的，通常需要使用**动态规划**或**贪心算法**等来解决。

### 5. 对数阶

与指数阶相反，对数阶反映了每轮缩减一半的情况如图 2-8 。时间复杂度为 $O (\log_{2}{n})$ ，简记为 $O (\log{n})$ ：

```Python
	def logarithmic(n: float) -> int:
	    """对数阶（循环实现）"""
	    count = 0
	    while n > 1:
	        n = n / 2
	        count += 1
	    return count
```

![](imgs/Pasted%20image%2020231215203124.png)

对数阶常出现于基于**分治策略**的算法中，体现了“**一分为多**”和“**化繁为简**”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。

```Python
	def log_recur(n: float) -> int:
	    """对数阶（递归实现）"""
	    if n <= 1:
	        return 0
	    return log_recur(n / 2) + 1
```

```ad-tip
#### $O (\log {n})$ 的底数是多少？

准确来说，“一分为 $m$ ”对应的时间复杂度是 $O (\log_{m}{n})$ 。然而，我们可以通过换底，得到相同的时间复杂度：

$$O (\log_{m}{n}) = O (\frac{\log_{k}{n}}{\log_{k}{m}}) = O (\log_{k}{n})$$

也就是说，底数并不影响复杂度，所以我们可以略去底数，简记为 $O (\log{n})$ 。
```

### 6. 线性对数阶

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 $O (n)$ 和 $O (\log{n})$ 。

```Python
	def linear_log_recur(n: float) -> int:
	    """线性对数阶"""
	    if n <= 1:
	        return 1
	    count: int = linear_log_recur(n // 2) + linear_log_recur(n // 2)
	    for _ in range(n):
	        count += 1
	    return count
```

图 2-9 展示了线性对数阶的生成方式。每一层的操作数都为 $n$ ，总共有 $\log_{2}{n} + 1$ 层，因此时间复杂度为 $O (n\log_{n})$ 。

主流排序算法的时间复杂度通常为线性对数阶，例如快速排序、归并排序、堆排序等。

### 7. 阶乘阶

阶乘阶对应数学上的“全排列”问题。阶乘通常使用递归实现。如图 2-9 和以下代码所示：

```Python
	def factorial_recur(n: int) -> int:
	    """阶乘阶（递归实现）"""
	    if n == 0:
	        return 1
	    count = 0
	    # 从 1 个分裂出 n 个
	    for _ in range(n):
	        count += factorial_recur(n - 1)
	    return count
```

![](imgs/Pasted%20image%2020231215204312.png)

## 2.3.5 最差、最佳、平均时间复杂度

**算法的时间效率往往不是固定的，而是与输入数据的分布有关**。假设输入一个长度为 $n$  的数组 `nums` ，其中 `nums` 由从 $1$ 至 $n$  的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 $1$  的索引。我们可以得出以下结论。

- 当 `nums = [?, ?, ..., 1]` ，即当末尾元素是 $1$  时，需要完整遍历数组，**达到最差时间复杂度** $O (n)$ 。
- 当 `nums = [1, ?, ?, ...]` ，即当首个元素为 $1$  时，无论数组多长都不需要继续遍历，**达到最佳时间复杂度** $O (1)$ 。

“**最差时间复杂度**”对应函数渐近上界，使用大 $O$  记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 $\Omega$ 记号表示。

值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。**而最差时间复杂度更为实用，因为它给出了一个效率安全值**，让我们可以放心地使用算法。

从上述示例可以看出，最差时间复杂度和最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，**平均时间复杂度可以体现算法在随机输入数据下的运行效率**，用 $\Theta$ 记号来表示。

对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 $1$  出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 $\frac{n}{2}$  ，平均时间复杂度为 $\Theta (\frac{n}{2}) = \Theta (n)$ 。

但对于较为复杂的算法，计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们**通常使用最差时间复杂度作为算法效率的评判标准**。

# 2.4 空间复杂度

「**空间复杂度 space complexity**」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。

## 2.4.1 算法相关空间

算法在运行过程中使用的内存空间主要包括以下几种。

- **输入空间**：用于存储算法的输入数据。
- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- **输出空间**：用于存储算法的输出数据。

一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

暂存空间可以进一步划分为三个部分。

- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。
- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。

在分析一段程序的空间复杂度时，**我们通常统计暂存数据、栈帧空间和输出数据三部分**，如图 2-10 所示。

![](imgs/Pasted%20image%2020231215205201.png)

```Python
	class Node:
	    """类"""
	    def __init__(self, x: int):
	        self.val: int = x              # 节点值
	        self.next: Node | None = None  # 指向下一节点的引用
	
	def function() -> int:
	    """函数"""
	    # 执行某些操作...
	    return 0
	
	def algorithm(n) -> int:  # 输入数据
	    A = 0                 # 暂存数据（常量，一般用大写字母表示）
	    b = 0                 # 暂存数据（变量）
	    node = Node(0)        # 暂存数据（对象）
	    c = function()        # 栈帧空间（调用函数）
	    return A + b + c      # 输出数据
```

```C++
	/* 结构体 */
	struct Node {
	    int val;
	    Node *next;
	    Node(int x) : val(x), next(nullptr) {}
	};
	
	/* 函数 */
	int func() {
	    // 执行某些操作...
	    return 0;
	}
	
	int algorithm(int n) {        // 输入数据
	    const int a = 0;          // 暂存数据（常量）
	    int b = 0;                // 暂存数据（变量）
	    Node* node = new Node(0); // 暂存数据（对象）
	    int c = func();           // 栈帧空间（调用函数）
	    return a + b + c;         // 输出数据
	}
```

## 2.4.2 推算方法

空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。

而与时间复杂度不同的是，**我们通常只关注最差空间复杂度**。这是因为内存空间是一项**硬性要求**，我们必须确保在**所有输入数据下都有足够的内存空间预留**。

观察以下代码，最差空间复杂度中的“最差”有两层含义。

1. **以最差输入数据为准** 。
2. **以算法中运行的峰值内存为准** 。

**在递归函数中，需要注意统计栈帧空间**。观察以下代码：

```Python
	def function() -> int:
	    # 执行某些操作
	    return 0
	
	def loop(n: int):
	    """循环 O(1)"""
	    for _ in range(n):
	        function()
	
	def recur(n: int) -> int:
	    """递归 O(n)"""
	    if n == 1: return
	    return recur(n - 1)
```

函数 `loop()` 和 `recur()` 的时间复杂度都为 $O (n)$ ，但空间复杂度不同。

- 函数 `loop ()` 在循环中调用了 $n$ 次 `function ()` ，每轮中的 `function ()` 都返回并 **释放了栈帧空间** ，因此空间复杂度仍为 $O (1)$ 。
- 递归函数 `recur ()` 在运行的过程中会同时存在 $n$ 个未返回的 `recur ()` ，从而占用了 $O (n)$ 的栈帧空间。

## 2.4.3 常见类型

设输入数据大小为 $n$  ，图 2-11 展示了常见的空间复杂度类型（从低到高排列）。

$$O (1) < O (\log {n) < O (n) < O (n \log {n}) < O (n^{2})} < O (n!)$$

![](imgs/Pasted%20image%2020231215210144.png)

### 1. 常数阶

常数阶常见于数量与输入数据大小 $n$  无关的常量、变量、对象。

需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 $O (1)$ 。

```Python
	def function() -> int:
	    """函数"""
	    # 执行某些操作
	    return 0
	
	def constant(n: int):
	    """常数阶"""
	    # 常量、变量、对象占用 O(1) 空间
	    a = 0
	    nums = [0] * 10000
	    node = ListNode(0)
	    # 循环中的变量占用 O(1) 空间
	    for _ in range(n):
	        c = 0
	    # 循环中的函数占用 O(1) 空间
	    for _ in range(n):
	        function()
```