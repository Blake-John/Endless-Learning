# 2.ROS通信机制
机器人是一种高度复杂的系统性实现，在机器人上可能集成各种传感器(雷达、摄像头、GPS...)以及运动控制实现，为了解耦合，在ROS中每一个功能点都是一个单独的进程，每一个进程都是独立运行的。更确切的讲，**ROS是进程（也称为**_**Nodes**_**）的分布式框架。** 因为这些进程甚至还可分布于不同主机，不同主机协同工作，从而分散计算压力。不过随之也有一个问题: 不同的进程是如何通信的？也即不同进程间如何实现数据交换的？在此我们就需要介绍一下ROS中的通信机制了。

ROS 中的基本通信机制主要有如下三种实现策略:
- 话题通信(发布订阅模式)
	- 发布者发布话题，订阅者按需获取信息
- 服务通信(请求响应模式)
	- 客户端向服务器请求响应，服务器根据请求发送信息给客户端
- 参数服务器(参数共享模式)
	- 存在一个用于存放参数的服务器，各个节点都可以向其中获取和存放参数
## 2.1 话题通信
#### 概念
话题通信是ROS中**使用频率最高**的一种通信模式，话题通信是基于**发布订阅**方式实现不同节点之间数据交互的通信模式，也即:一个节点发布消息，另一个节点订阅该消息。话题通信的应用场景也极其广泛，比如下面一个常见场景:

> 机器人在执行导航功能，使用的传感器是激光雷达，机器人会采集激光雷达感知到的信息并计算，然后生成运动控制信息驱动机器人底盘运动。

在上述场景中，就不止一次使用到了话题通信。

- 以激光雷达信息的采集处理为例，在 ROS 中有一个节点需要时时的发布当前雷达采集到的数据，导航模块中也有节点会订阅并解析雷达数据。
- 再以运动消息的发布为例，导航模块会根据传感器采集的数据时时的计算出运动控制信息并发布给底盘，底盘也可以有一个节点订阅运动信息并最终转换成控制电机的脉冲信号。

以此类推，像雷达、摄像头、GPS.... 等等一些**传感器数据的采集**，也都是使用了话题通信，换言之，话题通信适用于**不断更新的数据传输**相关的应用场景。
#### 作用
* 用于不断更新的、少逻辑处理的数据操作场景
### 2.1.1 理论模型
话题通信实现模型是比较复杂的，该模型如下图所示,该模型中涉及到三个角色:

- **ROS Master** (管理者)
- **Talker** (发布者)
- **Listener** (订阅者)

ROS Master 负责保管 Talker 和 Listener **注册**的信息，并**匹配话题相同的 Talker 与 Listener**，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。
![[01话题通信模型.jpg]]
整个流程由以下步骤实现:

 0. Talker注册
	Talker启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含所发布消息的话题名称。ROS Master 会将节点的注册信息加入到注册表中。

1. Listener注册
	Listener启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要订阅消息的话题名。ROS Master 会将节点的注册信息加入到注册表中。

2. ROS Master实现信息匹配
	ROS Master 会根据注册表中的信息匹配Talker 和 Listener，并通过 RPC 向 Listener 发送 Talker 的 RPC 地址信息。

3. Listener向Talker发送请求
	Listener 根据接收到的 RPC 地址，通过 RPC 向 Talker 发送连接请求，传输订阅的话题名称、消息类型以及通信协议(TCP/UDP)。
4. Talker确认请求
	Talker 接收到 Listener 的请求后，也是通过 RPC 向 Listener 确认连接信息，并发送自身的 TCP 地址信息。

5. Listener与Talker件里连接
	Listener 根据步骤4 返回的消息使用 TCP 与 Talker 建立网络连接。

6. Talker向Listener发送消息
	连接建立后，Talker 开始向 Listener 发布消息。

> 注意1:上述实现流程中，前五步使用的 RPC协议，最后两步使用的是 TCP 协议
> 
> 注意2: Talker 与 Listener 的启动无先后顺序要求
> 
> 注意3: Talker 与 Listener 都可以有多个
> 
> 注意4: Talker 与 Listener 连接建立后，不再需要 ROS Master。也即，即便关闭ROS Master，Talker 与 Listern 照常通信。