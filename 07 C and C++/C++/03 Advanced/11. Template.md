If we want to write a `Print ()` function and print out what we pass to it, we may need to overload the function many times to achieve that :

```C++
#include <iostream>

void Print (int value)
{
    std::cout << value << std::endl;
}

void Print (float value)
{
    std::cout << value << std::endl;
}

void Print (std::string value)
{
    std::cout << value << std::endl;
}

int main ()
{
    Print (0);
    Print (1.f);
    Print ("Hello");
}
```

But can we just write a function to achieve the goal instead of creating many overloaded functions ? The answer is using the **Template** .

# 01 How to create a template ?

To create a template, we should use the `template` keyword :

```C++
#include <iostream>

template <typename T>
void Print (T value)
{
    std::cout << value << std::endl;
}

int main ()
{
    Print (0);
    Print (1.f);
    Print ("Hello");
}
```

A template is specified by the **keyword** and the **name of the template** .

Let's consider the question : could the code below be compiled ?

```C++
#include <iostream>

template <typename T>
void Print (T value)
{
    std::cout << valu << std::endl;
}

int main ()
{
    std::cout << "Hello" << std::endl;
}
```

It seems that there is an error in the function `Print ()` , but exactly, the function `Print ()` is **not a true function and does not exist in the program above** . This is because the template will **only be created when we call the template**. Since the program above does not call `Print ()` , the program **does not create the function** **`Print ()`** . So there is not an error.

> But whether the code could be compiled or not depends on the compiler you choose !

# 02 Template in Class

## 2.1 One Parameters

Now, let's look at the templates in class.

If we want to create our own `Array` class **on the stack** , which means the class has a private attribute `m_Array[]` . But we **need to specify the size of the array (Although the new standard of C++ allows you to create or specify the size of the array by a variable, the variable in a class could not achieve this goal)** . This time, we can create a template of class to set the size automatically :

```C++
#include <iostream>

template <int N>
class Array
{
    private:
        int m_Array[N];
    public:
        int GetSize () { return N; }
};

int main ()
{
    Array<5> array;
    std::cout << array.GetSize () << std::endl;
    return 0;
}
```

In the template, we can specify the type of the template to `int` , then we use the template to create an instant. The code above is the same as :

```C++
#include <iostream>

class Array
{
    private:
        int m_Array[5];
    public:
        int GetSize () { return 5; }
};

int main ()
{
    Array array;
    std::cout << array.GetSize () << std::endl;
    return 0;
}
```

## 2.2 Multiple Parameters

If we want to specify the type of the array created by `Array` , we can add another parameter in templates and use it to create the class :

```C++
#include <iostream>

template <typename T, int N>
class Array
{
    private:
        T m_Array[N];
    public:
        T GetSize () { return N; }
};

int main ()
{
    Array<int, 5> array;
    std::cout << array.GetSize () << std::endl;
    return 0;
}
```

In the code above, we create a template with `typename T` and `int N` and use these two templates to create the class.