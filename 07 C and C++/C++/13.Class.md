# Chapter 1 : A Brief Introduction of Class
## 1.1 What is Class  ?
- In brief, class is a method to **group datas and functionalities together**
## 1.2 Why we need Class ?
- In the game programming, we need a character with some attributes.
- If we write the code by the method of procedure oriented, it will be
```Cpp
int main ()
{
	// we are going to write some attributes of the character
	// such as its position and moving speed
	int x, y;
	int speed;
}
```
- the code above seems not to be so strange, but the variable has no exact meaning, so we may
```Cpp
int main ()
{
	// we are going to write some attributes of the character
	// such as its position and moving speed
	int PlayerX, PlayerY;
	int PlayerSpeed;
}
```
- it looks great !
- but if we are going to add another character, we need to do so
```Cpp
int main ()
{
	// we are going to add another character
	int Player1X, Player1Y;
	int Player2X, Player2Y;
	int Player1Speed;
	int Player2Speed;
}
```
- it is going to be somewhat confusion, what if we add the third character ?
> In order to promote the reusing of code and make it easier to maintain, we need the method of [[12.OOP|OOP]] , in which, the concept of class is important

## 1.3 How to use a Class ?
### 1.3.1 create a class
```Cpp
class <name>
{
	<codes>
};
```
```ad-tip
- the **name of the class must be the only one** 
- Comparision with the function, **there must be a `;` after the definition of a class**
```
- so we can write the code above like : 
```Cpp
class Player
{
	int x, y;
	int speed;
};
```
- by now, we have successfully create a data type named `Player`
### 1.3.2 use the class
- since the **class is just a new type of data** , we can use it to create an **object** like we defining other type of variables
```Cpp
Player player;
```
- variables made from class type are called **objects** , and new object variable is called **instance**
### 1.3.3 edit the object
#### 01 Access the variables in the class
- if now we going to `main` function, and write
```Cpp
int main ()
{
	player.x = 5;
}
```
- it will get an error
	- `cannot access private member declared in class "Player"`
- it is because by default, the every member in a class is **private**
	- which means only the **function inde that class can access these members**
- so we can set these variables be `public`
```Cpp
class Player
{
	public :
		int x, y;
		int speed;
};

int main ()
{
	Player player;
	player.x = 5;
}
```

#### 02 The function in the class
- we wants to write a function to control the character to move (change the position variables) , we can
```Cpp
void Move (Player &player, int dx, int dy)
{
	player.x += dx * player.speed;
	player.y += dy * player.speed;
}

int main ()
{
	Move (player, 5, 5);
}
```
- but exactly, we can move the `Move` function into the class, because a class can contain some function
	- function inside the class is called **method**
```Cpp
class Player
{
	public :
		int x, y;
		int speed;

		void Move (int dx, int dy)
		{
			x += dx * speed;
			y += dy * speed;
		}
};

int main ()
{
	player.Move (1, -1);
}
```

# Chapter 2 : The Difference between Class and Structure
- the member in **class** is **private by default**
- but the member in **struct** is **public by default**
## Why the `struct` still exist in C++ ?
- because the C++ need to **be compatible with the old standard and C**
	- we can use `struct` to group some datas, just the collection of datas
	- we can use `class` to create a object with many complex attributes and methods
# Chapter 3 : How to write a class ?
> in this chapter, we are going to write a class `Log` to log out the informations

```Cpp
#include <iostream>

class Log
{
public :
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;

public:
	void SetLevel(int level)
	{
		m_LogLevel = level;
	}

	void Warn(const char* message)
	{
		if (m_LogLevel >= LogLevelWarning)
		{
			std::cout << "[Warn] : " << message << std::endl;
		}
	}

	void Error(const char* message)
	{
		if (m_LogLevel >= LogLevelError)
		{
			std::cout << "[Error] : " << message << std::endl;
		}
	}

	void Info(const char* message)
	{
		if (m_LogLevel >= LogLevelInfo)
		{
			std::cout << "[Informations] : " << message << std::endl;
		}
	}

private:
	int m_LogLevel = LogLevelInfo;
};


int main()
{
	Log log;
	log.SetLevel(log.LogLevelError);
	log.Warn("Hello!");
	log.Info("Hello!");
	log.Error("Hello!");

	std::cin.get();
	return 0;
}
```

# Chapter 4 : Static
## 4.1 Static in the normal code
### 4.1.1 Static

- a static variable is said that the variable is **only visable in the translation section** ^ce184e
- assume that we have such a file structure

```
chapter4
	|__ Static.cpp
	|__ Main.cpp
```

- in the `Static.cpp` , we have

```Cpp
static int s_variable = 5;
```

- in the `Main.cpp` , we have

```Cpp
#include <iostream>

int main ()
{
	s_variable = 10;
	std::cout << s_variable << std::endl;
}
```

- the output will be `10`
- but if in the `Static.cpp` , we have

```Cpp
int s_varible = 5;
```
- we will get a **linking error**
	- because we can't define a variable twice
	![](07%20C%20and%20C++/C++/imgs/13.ClassImgs/屏幕截图%202023-11-25%20114922.png)

```ad-tip
so, by here, you can easily understand 

![](13.Class#^ce184e) 

means the variable with `static` attribute can only be visable int the minimal translation section, the other file could not access the variable
```

### 4.1.2 Extern

- if we wants to find a variable outside this translation, we can define a same name variable by `extern`
	- which called **external linking**
- in `Main.cpp`

```Cpp
#include <iostream>

extern int variable;

int main ()
{
	std::cout << variable << std::endl;
}
```

- in `Static.cpp`

```Cpp
int variable = 10;
```

- the output will be `10` 

```ad-attention
1. **We can't have two global variable with same name**
2. if we define a variable as `static` , we can't find the variable at other translation units , **although there is an `extern` before the variable**

- in `Static.cpp`

	```Cpp
	static int variable = 5;
	```
	
- in `Main.cpp`

	```Cpp
	#include <iostream>

	extern int variable;

	int main ()
	{
		std::cout << variable << std::endl;
	}
	```

- this will lead to a linking error
	- because the compiler could not find a external symbol `int variable`
```

```ad-seealso
- the keyword `static` is **not only can affect the variable, but also the functions**
	- if we set the functin to be `static` , it can not be found in other translation units
- but the `extern` could not act on the function , because if we want to use an external function , we will include that file
```

## 4.2 Static inside Class
- the static variable inside the class means no matter how many instances you create, there is only one variable in the memory
### Not to use `static`

- Let's see some codes

```Cpp
#include <iostream>

struct Entity
{
	int x, y;

	void Print ()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int main ()
{
	Entity e;
	e.x = 2;
	e.y = 3;

	Entity e1 = {5, 8};

	e.Print ();
	e1.Print ();

	return 0;
}
```

- the output will be

```
2, 3
5, 8
```

### use `static`

- if we use static to define the variable `x` and `y` ,such as

```Cpp
#include <iostream>

struct Entity
{
	static int x, y;

	void Print ()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int main ()
{
	Entity e;
	e.x = 2;
	e.y = 3;

	Entity e1 = {5, 8};

	e.Print ();
	e1.Print ();

	return 0;
}
```

- this will lead to an error, which tell us there is too many initial value of `x` and `y`
	- it is because by writing `Entity e1 = {5, 8};` , we are going to initialize the variable in the struct, but actually we can't write this
- if we replace `Entity e1 = {5, 8};` with `Entity e1;` , there will come to the second problem
	- `unresolved external symbol`
	- which tell us that we can't find the definition of `x` and `y`
	- that is, the **static variable must be initialized**
- so we can write this

```Cpp
struct Entity
{
	static int x, y;

	void Print ()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int Entity::x;
int Entity::y;

int main ()
{
	Entity e;
	e.x = 2;
	e.y = 3;

	Entity e1;
	e1.x = 5;
	e1.y = 8;

	e.Print ();
	e1.Print ();
	

	return 0;
}
```

```ad-attention
- we can't give it a initial value in the struct, like
	
	```Cpp
	struct Entity
	{
		static int x = 0, y = 0;
	};
	```
	
- maybe it is because if we do so, we **will initialize the value each time we create a new date using type `Entity`**.
- but the **static variable must have a constant initial value**
```

- the output of the program will be

```
5, 8
5, 8
```

```ad-summary
#### Why the output is that ?
1. it is because the static variable in the struct **have only one instance**
2. no matter how many object we create, there will only one instance of `x` and `y`
3. so actually, when we write `e1.x` and `e.x` , we are going to **access the same variable, which means we are getting the value from the same memeory address**
```

- so instead of write `e1.x` to access the variable `x` , it is more clear to write `Entity::x`
	- which is like to create `x` and `y` in the namespace called `Entity`

```ad-seealso
- the s**tatic methods** in struct or class is **the same as variables**
```

```ad-attention
- **the static method could not access a variable which is not static**
```

- Let's see the codes

```Cpp
struct Entity
{
	int x, y;

	static void Print()
	{
		std::cout << x << ", " << y << std::endl;
	}
};


int main()
{
	Entity e;
	Entity e1;

	e.x = 2;
	e.y = 3;

	e1.x = 5;
	e1.y = 8;


	e.Print();
	e1.Print();


	return 0;
}
```

- this will lead to an error
	- `illegal reference to non-static member 'Entity::x'`
	- the reason is 
		- the **static method have no a class instance**
		- but the **non-static variable is associated with an class instance**
	- so it is **the same as we write a function outside the class and try to access the variable inside the class**

```ad-tip
every nonstatic method always **get an instance of this class to be the arguement**
```

- so the code above is actually like this in the compiler :

```Cpp
struct Entity
{
	int x, y;

};
static void Print()
{
	std::cout << x << ", " << y << std::endl;
}
```

## 4.3 Local Static
- a variable set to static **in a function/class** , this variable is **just visible to that function/class** , you can't access the variable outside the function or the class  

```Cpp
class Singleton
{
public :
	static Singleton& Get()
	{
		static Singleton instance;
		return instance;
	}

	void hello()
	{
		std::cout << "Hello" << std::endl;
	}
};


int main()
{
	Singleton::Get ().hello ();

	return 0;
}
```

# Chapter 5 : Enumeration
- an enumeration is a group of some data
- any variable created by this type only has the value in the enumeration type, such as
```Cpp
#include <iostream>

enum Example
{
	A, B, C
};

int a = 0;
int b = 1;
int c = 2;

int main()
{
	Example value = 5;

	if (value == B)
	{

	}

	return 0;
}
```
- the sentence `Example value = 5;` will ==lead to an error==
	- because the **`Example` type of variable only has the value `A` `B` `C`** , you can't initialize the variable by other value.
- and the value of the `A` `B` `C` is by default `0` `1` `2`
- but you can set them to any value you want, and they will increasing one by one
- also, you can set the date type in the enumeration, such as
```Cpp
enum Example : unsigned char
{
	A, B, C
};

int a = 0;
int b = 1;
int c = 2;

int main()
{
	Example value = B;

	if (value == 1)
	{
		std::cout << value << std::endl;
	}

	return 0;
}
```

```ad-attention
- the value/data type in a enumeration must be the type of `int` or type **related to `int`**
- such as
	- `int`
	- `unsigned int`
	- `unsigned char`
- not
	- `float`
	- `double`
```

- Let's jump back to the log class
```Cpp
class Log
{
public:
	enum LogLevel
	{
		LevelError = 0, LevelWarning, LevelInfo
	};

public:
	void SetLevel(LogLevel level)
	{
		m_LogLevel = level;
	}

	void Warn(const char* message)
	{
		if (m_LogLevel >= LevelWarning)
		{
			std::cout << "[Warn] : " << message << std::endl;
		}
	}

	void Error(const char* message)
	{
		if (m_LogLevel >= LevelError)
		{
			std::cout << "[Error] : " << message << std::endl;
		}
	}

	void Info(const char* message)
	{
		if (m_LogLevel >= LevelInfo)
		{
			std::cout << "[Informations] : " << message << std::endl;
		}
	}

private:
	int m_LogLevel = LevelInfo;
};


int main()
{
	Log log;
	log.SetLevel(Log::LevelError);
	log.Warn("Hello!");
	log.Info("Hello!");
	log.Error("Hello!");

	std::cin.get();
	return 0;
}
```


# Chapter 6 : Constructor
## 6.1 How to create a constructor

`constructor` is a special method which will **run every time we create an object** . Let's see an example : 

```Cpp
#include <iostream>

class Entity
{
public :
	float X, Y;

	void Print()
	{
		std::cout << X << '\t' << Y << std::endl;
	}
};

int main()
{
	Entity e;
	std::cout << e.X << std::endl;

	return 0;
}
```

if we want to print the `X` , it will lead to an error, which tell us that the `X` is an uninitialized local variable. So we need some method to **initialize the instance when it was created** , that is a constructor.

> A constructor is a function that we use to **initialize the class instant** 

```ad-attention
- the `constructor` will only be called when we create an instance
- so if we just use the static method, it won't run
```

The C++ give us an empty constructor by default, so that when we create an instant, it will run the constructor but do nothing.

We can define our own
constructor by : 

```C++
#include <iostream>

class Entity
{
public :
	float X, Y;
	// Declare a constructor
	Entity ()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Print()
	{
		std::cout << X << '\t' << Y << std::endl;
	}
};

int main()
{
	Entity e;
	std::cout << e.X << std::endl;

	return 0;
}
```

## 6.2 A constructor with other parameters

The constructor acts the same as the normal functions, so that we can have a constructor with passed parameters : 

```C++
#include <iostream>

class Entity
{
public :
	float X, Y;
	// constructor with parameters
	Entity (float x, float y)
	{
		X = x;
		Y = y;
	}

	void Print()
	{
		std::cout << X << '\t' << Y << std::endl;
	}
};

int main()
{
	// in this case, we need to pass the parameter to create a instant
	Entity e (5.0f, 10.0f);
	std::cout << e.X << std::endl;

	return 0;
}
```

## 6.3 How to hide the constructor
If I just want to Let someone else to **use the static method, and don't create an instanc**e, we can hide the constructor : 
- that is, we can **set the constructor to be invisible outside the class**
	- because when ever we want to create an instance, it will run the constructor
	- so if it couldn't run the constructor, we couldn't create an instance
- To achieve this, we can **set the constructor to the private**

```Cpp
class Entity
{
	public :
		static void Log ()
		{
		}

	private :
		Entity ()
		{
		}
};

int main ()
{
	Entity l; // this will lead to an error

	return 0;
}
```

- or we can simply **delete the constructor**

```Cpp
class Entity
{
	public :
		static void Log ()
		{
		}

		Entity () = delete;
};

int main ()
{
	Entity l; // this will lead to an error

	return 0;
}
```

set the constructor to be invisible outside the class

# Chapter 7 : Destructor

## 7.1 What is a Destructor

In contrary to a constructor, a destructor is a special method when an instant is going to be deleted. The destructor will **uninitialize the variables** , **clean the memory** and so on.

## 7.2 Create a Destructor

```C++
#include <iostream>

class Entity
{
public :
	float X, Y;
	// constructor with parameters
	Entity (float x, float y)
	{
		X = x;
		Y = y;
		std::cout << "Constructed Entity !" << std::endl;
	}

	// define a destructor
	~Entity ()
	{
		std::cout << "Destroyed Entity !" << std::endl;
	}

	void Print()
	{
		std::cout << X << '\t' << Y << std::endl;
	}
};

void Function ()
{
	Entity e (5.0f, 10.0f);
	e.Print ();
}

int main()
{
	Function ();

	return 0;
}
```

If we run this code, the output will be : 

```
Constructed Entity !
5.0    10.0
Destroyed Entity !
```

> [!attention] 
> When you **manually assign the memory to some variable, we need to delete the variable manually so as to avoid the leak of the memory** .

# Chapter 8 : Inheritance

**Inheritance** is a important feature of C++ Class. It allows us to **avoid the codes repetation** when we may use some code by many times but some of the methods we want to do a little change.

Assume that we have a basic class `Entity` and we want to create a new class `Player` :

```C++
#include <iostream>

class Entity
{
	public : 
		float X, Y;

		void move (float xa, float ya)
		{
			X += xa;
			Y += ya;
		}
};

class Player
{
	public : 
		const char* Name;
		float X, Y;

		void move (float xa, float ya)
		{
			X += xa;
			Y += ya;
		}

		void PrintName ()
		{
			std::cout << Name << std::endl;
		}
};

int main ()
{

	return 0;
}
```

We can see that the class `Player` is very similar to the class `Entity` , so that there are **many codes just be copied and pasted**. But this is actually a new class with new attribute `Name` and new method `PrintName` .

To avoid the code repetition in the program, we can let `Player` inherits `Entity` : 

```C++
#include <iostream>

class Entity
{
	public : 
		float X, Y;

		void move (float xa, float ya)
		{
			X += xa;
			Y += ya;
		}
};

// Inherit the class Entity
class Player : public Entity
{
	public : 
		const char* Name;

		void PrintName ()
		{
			std::cout << Name << std::endl;
		}
};

int main ()
{

	return 0;
}
```

Now the class `Player` has not only its own attribute `Name` and method `PrintName ()` , but also has the attributes `X` , `Y` and method `move ()` ;

# Chapter 9 : Virtual Function

## 9.1 What is a Virtual Function

**Virtual Function** allows us to **override the functions in subclass** . The core of the virtual function is that **the virtual function provides a method to access to the subclass method from the parent class variable** .

Assume that we have two class `A` and `B` and `B` is the subclass of `A` , or we can say `B` inherit the class `A` . If we **mark a function to be *virtual* in class `A`** , then we can override the function in `B` so that the function can do another thing or we can leave the function to be original.

Let's see the code bellow : 

```C++
#include <iostream>

class Entity
{
	public :
		const char* GetName () { return "Entity"; }

};

class Player : public Entity
{
	private :
		const char* m_Name;

	public :
		Player (const char* name) : m_Name (name) {}
		
		const char* GetNamew () { return m_Name; }
};

int main ()
{
	Entity* e = new Entity;
	std::cout << e->GetName () << std::endl;

	Player* p = new Player ("Cherno");
	std::cout << p->GetNamew () << std::endl;

	return 0;
}
```

This is a good code that if we run it, it will output :

```
Entity
Cherno
```

But if we add a two line : 

```C++
#include <iostream>

class Entity
{
	public :
		const char* GetName () { return "Entity"; }

};

class Player : public Entity
{
	private :
		const char* m_Name;

	public :
		Player (const char* name) : m_Name (name) {}
		
		const char* GetName () { return m_Name; }
};

int main ()
{
	Entity* e = new Entity;
	std::cout << e->GetName () << std::endl;

	Player* p = new Player ("Cherno");
	std::cout << p->GetName () << std::endl;

	Entity* entity = p;
	std::cout << entity->GetName () << std::endl;

	return 0;
}
```

However, if we let `Player` inherit `Entity` , it will lead to an mistake : 

```
Entity
Cherno
Entity
```

Although we define a pointer with type `Entity` , but we **assign the memory address of `Player` to the pointer** , so the pointer is actually point to a class `Player` . But why the third output is `Entity` instead of `Cherno` ?

That is because when compile call the function, it will go into the class and then call that function. The type of `entity` is `Entity` , so the program will call the function `GetNaem ()` from `Entity` instead of `Player` .

To solve this problem, we just need to define the `GetName ()` in `Entity` as a **virtual function** . The virtual function is something about **dynamic dispatch** , which will generate a **v-table** to tell the compile to find the function right.

```C++
class Entity
{
	public :
		virtual const char* GetName () { return "Entity"; }

};
```

In this time, the output will be : 

```
Entity
Cherno
Cherno
```

And another thing we can do is to define the function `GetName ()` in `Palyer` as a **overrided function** . This is optional but there are two advantages :

- The code will be more **readable**
- **Avoid some bug** such as 
	- if we write a wrong function name to be overrided, the clangd could not find any function to be overrided, and we will know there is a bug
	- if we want to override the function in the parent class but the function is not a virtual function, that will lead to error when we add **override** keyword

```C++
class Player : public Entity
{
	private :
		const char* m_Name;

	public :
		Player (const char* name) : m_Name (name) {}
		
		const char* GetName () override { return m_Name; }
};
```

## 9.2 A Pure Virtual Function

### 9.2.1 Definition

A **Pure Virtual Function** allows us to declare a **non-defined function** in a class and **force us to give a definition in the subclass** .

It is common to define a class **with only some declaration** and force the subclass to give the definitions, this is called ***Interface*** . And the interface in the class only contains the non-completed function, which serve as **templates** .

To define a pure virtual function, we just need to throw out the definition in `Entity` , and **set it to be 0** : 

```C++
class Entity
{
	public :
		virtual const char* GetName () = 0;

};
```

By doing this, we can find that we can no longer use `Entity` to create an instant, but the `Player` still work because we has already define that virtual function `GetName ()` .

### 9.2.2 Example

Such as  we want to write a function to **print out the name of the class**, then, we need to **pass the class or the pointer to the class** as a parameter, and **call the method of that class** : 

```C++
void Print (Printable* obj)
{
	std::cout << obj->GetClassName () << std::endl;
}
```

In this case, we can write a `Printable` class to declare a pure virtual function `GetClassName ()` and let other classes inherit it. So that we can have the interface `GetClassName ()` : 

```C++
class Printable
{
	public :
		const char* GetClassName () = 0;
}
```

Then, as is tried above, we can let class `Entity` inherit it and let `Player` inherit `Entity` . By doing so, we **can use the pointer with type  `Printable` to call the method `GetClassName` in *subclass* `Entity` and `Player`** : 

```C++
#include <iostream>

class Printable
{
	public :
		virtual const char* GetClassName () = 0;
};

class Entity : public Printable
{
	public :
		const char* GetName () { return "Entity"; }
		const char* GetClassName () override { return "Entity"; }

};

class Player : public Entity
{
	private :
		const char* m_Name;

	public :
		Player (const char* name) : m_Name (name) {}
		
		const char* GetName () { return m_Name; }
};

void Print (Printable* obj)
{
	std::cout << obj->GetClassName () << std::endl;
}

int main ()
{
	Entity* e = new Entity;
	// std::cout << e->GetName () << std::endl;
	Print (e);

	Player* p = new Player ("Cherno");
	// std::cout << p->GetName () << std::endl;
	Print (p);

	Entity* entity = p;
	// std::cout << entity->GetName () << std::endl;
	Print (entity);

	return 0;
}
```

The code will run properly and the ouput is :

```
Entity
Entity
Entity
```

This is because class `Entity` has override the pure virtual function `GetClassName ()` but `Player` does not. And `Player` inherits `Entity` so that it inherits the definition of `GetClassName ()` .

If we let `Player` inherit `Printable` and do not give the definition of `GetClassName ()` in the class, the instant `p` could not be created.

Then, we give the definition in `Player` : 

```C++
class Player : public Entity
{
	private :
		const char* m_Name;

	public :
		Player (const char* name) : m_Name (name) {}
		
		const char* GetName () { return m_Name; }
		const char* GetClassName () override { return "Player"; }
};
```

The output will be :

```
Entity
Player
Player
```

# Chapter 10 : Visibility

**Visibility** is a important concept in OOP and demands that **who can see the attributes or methods** , **who can call them** , and **who can use them** .

The basic keyword to decorate the attributes and methods is :

- `public` - **can be accessed in every where**
- `private` - **Only* this class can access the attributes or methods** 
- `protected` - **Only* the related class can access the members** 

> [!note] 
> #### Default Type
> If you not define a visibility type in a class or a struct, then
> 
> - `public` - the default visibility type in **struct** 
> - `private` - the default visibility type in **class** 

That is, the code bellow two blocks are the same : 

```C++
struct Entity_s
{
	int a, b;
};

class Entity_c
{
	int a, b;
};
```

```C++
struct Entity_s
{
	public :
		int a, b;
};

class Entity_c
{
	private :
		int a, b;
};
```

## 10.1 `private` 

`private` means **Only* *in* this class an access the attributes or methods*** . If you try to access the attributes or methods out side the field of the class **such as in another function or in main function** , it will lead to an error.

```C++
#include <iostream>

class Entity
{
	public :
		Entity ()
		{
			X = 1;
			Y = 2;
			Print ();
		}
		
	private :
		int X, Y;
		void Print () {}
};

class Player : public Entity
{
	public :
		Player ()
		{
			X = 2;
			Print ();
		}
};

int main ()
{
	Entity e;
	e.Print ();
	std::cout << e.X << std::endl;

	return 0;
}
```

The code above try to call the **private attribute** `X` and **private method** `Print ()` of class `Entity` in `main` function or class `Player` , this will fail to compile because we call the private member out side the class `Entity` .

> [!note] 
> #### Why Only plus \*
> This is because there is a keyword `friend` that can let some function or class to be the friend of this class and then they can access the private attributes or methods.

## 10.2 `protected` 

`protected` is little more visible than `private` but less visible than `public` . `protected` means that **only* in the class or in subclass can access the members and in other also could not access the members** .

```C++
class Entity
{
	public :
		Entity ()
		{
			X = 1;
			Y = 2;
			Print ();
		}
		
	protected :
		int X, Y;
		void Print () {}
};
```

If we set `X` , `Y` , `Print ()` to be `protected` , then, we can access `X` , `Y` in the subclass `Player` and call the function `Print ()` in `Player` . But we still could not access them in `main` function.

## 10.3 `public` 

`public` means **you can access the member in every where** such as in the class, in subclass, in main function ...

# Chapter 11 : Constructor Member Initializer List

This chapter is about how to initialize the member in the class. There is basically two way to initialize the member : 

- In the constructor
- Use constructor member initializer list

## 11.1 Init the Members in Constructor

Assume we have the class : 

```C++
#include <iostream>

class Entity
{
	public :
		Entity ();
		const char* GetName () const { return m_Name; }
	private :
		const char* m_Name;
};

int main ()
{


	return 0;
}
```

If we want to init the attribute `m_Name` in the constructor, then we can : 

```C++
#include <iostream>

class Entity
{
	public :
		Entity () 
		{
			m_Name = "Unknown";
		}
		Entity (const char* name)
		{
			m_Name = name;
		}
		const char* GetName () const { return m_Name; }
	private :
		const char* m_Name;
};

int main ()
{
	Entity e0;
	std::cout << e0.GetName () << std::endl;

	Entity e1 ("Cherno");
	std::cout << e1.GetName () << std::endl;

	return 0;
}
```

In the code above, we pass the parameter `name` to `Entity ()` and then inside the `Entity ()` , we assign `m_Name` to be `name` .

## 11.2 Initializer List

Another way to init the member is to use the initializer list : 

```C++
#include <iostream>

class Entity
{
	public :
		Entity () : m_Name ("Unknown"), m_Score (0) {}
		Entity (const char* name, int score) : m_Name (name), m_Score (score) {}
		const char* GetName () const { return m_Name; }
	private :
		const char* m_Name;
		int m_Score;
};

int main ()
{
	Entity e0;
	std::cout << e0.GetName () << std::endl;

	Entity e1 ("Cherno", 0);
	std::cout << e1.GetName () << std::endl;

	return 0;
}
```

**We can type a `:` after the constructor and use `()` to pass the value to the attributes. If there are one more attributes to be initialized, we just write an comma and then init again.** 

> [!note] 
> It is better to initialize the attributes by the order you declare the attributes.

## 11.3 Why we need initializer list ?

It seems that the initializer list is totally the same as the constructor, but in fact, the **initializer list is more effective**. Let's see the code bellow : 

```C++
#include <iostream>

class Example
{
	public :
		Example ()
		{
			std::cout << "Created Entity !" << std::endl;
		}

		Example (int x)
		{
			std::cout << "Created Entity with " << x << " !" << std::endl;
		}
};

class Entity
{
	public :
		Entity ()
		{
			m_Name = "Unknown";
			m_Example = Example (8);
		}
		Entity (const char* name);

		const char* GetName () { return m_Name; }
	private :
		const char* m_Name;
		Example m_Example;
};


int main ()
{
	Entity e;
}
```

The code above is use the constructor to initial the `m_Name` and `m_Example` . The output is :

```
Created Entity !
Created Entity with 8 !
```

Why will `m_Example` called twice the constructor ? 

It is because  when we create the attribute `m_Example` , in the private, `Example m_Example;` called the constructor once and in `Entity ()` , `m_Example = Example (8);` called the constructor again. So when we create an instant `e` , we actually create the instant `m_Example` twice, but the second instant override the first instant.

This is a waste of the computor resources, but while we use the initializer list : 

```C++
#include <iostream>

class Example
{
	public :
		Example ()
		{
			std::cout << "Created Entity !" << std::endl;
		}

		Example (int x)
		{
			std::cout << "Created Entity with " << x << " !" << std::endl;
		}
};

class Entity
{
	public :
		Entity () : m_Name ("Unknown"), m_Example (Example (8)) {}
		Entity (const char* name);

		const char* GetName () { return m_Name; }
	private :
		const char* m_Name;
		Example m_Example;
};


int main ()
{
	Entity e;
}
```

The output will be : 

```
Created Entity with 8 !
```

# Chapter 12 : 