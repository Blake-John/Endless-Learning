# 01 实现思路

# 02 实现代码

# 03 模块详解

## 3.1 `<fcntl.h>` 

`<fcntl.h>` 是 C 语言中的一个头文件，它提供了一些用于 **文件控制** 的 **常量** 和 **函数原型** 。具体来说，该头文件主要用于以下几个方面：

1. **文件打开和关闭**：该头文件定义了 `open()` 和 `close()` 函数，用于 **打开和关闭文件**。open() 函数接受文件路径和标志位作为参数，并返回一个文件描述符，以后的读写操作都通过该文件描述符进行。close() 函数用于关闭已打开的文件。
	
2. **文件权限设置**：通过 `open()` 函数的参数可以 **指定文件的访问权限**。fcntl.h 中定义了一些常量，如 `O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（可读写）` 等，可以与 open() 函数的标志位进行组合，来设置文件的权限。
	
3. **文件操作标志位**：fcntl.h 中定义了一些标志位，用于 **控制文件的行为**。比如 `O_CREAT（若文件不存在则创建）、O_EXCL（若文件存在则报错）、O_APPEND（追加写入）` 等。
	
4. **文件控制函数**：该头文件还包含了一些文件控制的函数原型，如 fcntl()、fcntl64() 等，这些函数用于对已打开的文件进行各种控制操作，如修改文件状态标志、获取文件状态等。

总的来说，fcntl.h 提供了一系列用于文件控制的常量和函数，使得我们可以在 C 语言程序中对文件进行打开、关闭、读写以及其他一些控制操作。这使得我们能够更好地管理和操作文件，提高程序的灵活性和可扩展性。

### 3.1.1 `open ()` 

> 用于打开一个文件，并返回一个文件描述符（file descriptor），以便后续对文件的读写操作。

**Declaration :** 
- `int open(const char *__file, int __oflag, ...)` 

**Parameters :** 
1. `const char *__file` : 要打开的文件路径名。
	
2. `int __oflag` : 打开文件的 **标志位**，用于指定文件的 **打开方式和行为**。
	- `O_RDONLY`: 仅以 **只读** 方式打开文件。
	- `O_WRONLY`: 仅以 **只写** 方式打开文件。
	- `O_RDWR`: 以 **可读写** 方式打开文件。
	- `O_CREAT`: 若文件 **不存在则创建文件**。如果文件 **已存在，则不会修改文件的内容，但允许进行读写操作**。需要注意的是，此时必须指定第三个参数 `mode`，设置新建文件的权限。
	- `O_EXCL`: **如果文件已存在，不打开文件**。若同时指定了 `O_CREAT` 标志位，且文件已经存在，则返回错误。这个标志常常与 `O_CREAT` 一起使用，确保创建的文件不存在。
	- `O_TRUNC`: 若文件已存在，则 **将文件的大小截为0**。如果文件不存在，则忽略此标志位。
	- `O_APPEND`: 打开文件时，将文件指针定位到文件的末尾。每次写入数据时，都会 **追加写入** 到文件末尾处。
		
	- `O_NONBLOCK` ：以 **非阻塞模式** 打开文件，如果文件不可用，不会阻塞等待。
	- `O_SYNC` ：以 **同步模式** 打开文件，对文件进行磁盘写入操作后，确保数据已写入磁盘。
	- `O_ASYNC` ：以 **异步模式** 打开文件，对文件的读写操作不等待磁盘操作完成。
	- `O_DIRECT` ：以 **直接模式** 打开文件，**绕过缓冲区，直接对磁盘进行读写**。
	- `O_DIRECTORY` ：**打开一个目录**，而不是打开一个文件。
	- `O_NOFOLLOW` ：如果路径是符号链接，不follow其链接到目标。
	- `O_NOATIME` ：**不要更新文件的访问时间**。
	- `O_CREATE_MISSING_DIRS` ：**如果目录不存在，创建它**。
		
	- `O_NOCTTY` ：表示 **不要将此文件视为终端设备**。这通常在创建伪终端对时使用，如在某些Linux系统上 **创建与硬件设备的伪终端**。
	- `O_NDELAY` ：表示 **不使用NORMAL DELAY模式**。在某些情况下，这可以提高异步I/O操作的性能。

**Return :** 
- `open()` 函数返回一个 **非负数的 「文件描述符」**，表示打开的文件。如果 **打开文件失败，则返回-1**，并设置 `errno` 错误码来指示具体的错误原因。

> [!note] 
> **「文件描述符」** 是系统用来 **表示文件或目录的的唯一整数**。文件描述符可以用来进行文件读写操作，如使用 `read()` 和 `write()` 函数读写文件。文件描述符还可以用于 **检查文件的状态**，如检查文件是否已关闭、是否可读、是否可写等。

## 3.2 `<termios.h>` 

`<termios.h>` 是一个 C 语言头文件，它 **包含了与终端 I/O 相关的函数和数据类型** 的定义。`termios`是一个用于处理通信协议的C++库，它提供了低级别的 **通信控制**。通过使用 `<termios.h>` 头文件，我们可以 **对终端进行输入和输出的控制**。

以下是 `<termios.h>` 中一些常用的函数和数据类型：

1. `tcgetattr()` 和 `tcsetattr()`: 这两个函数用于 **获取** 和 **设置** 终端的 **属性**。
	- `tcgetattr()` 函数可以获取当前终端的属性，并将其 **保存在一个结构体中**；
	- `tcsetattr()` 函数则用于 **设置终端的属性**，通过 **传递一个结构体参数** 来指定所需的属性。
    
2. `struct termios`: 这是一个用于 **存储终端属性的结构体**。它包含了很多字段，用于描述终端的各种特性，如输入模式、输出模式、控制字符等。
    
3. `cfsetispeed()` 和 `cfsetospeed()`: 这两个函数用于 **设置终端的输入和输出波特率**。它们可以将指定的波特率值设置到终端属性的相应字段中。
    
4. `cfmakeraw()`: 这个函数可以 **将终端属性设置为原始模式**，即 **禁用终端的特殊处理和输入行编辑**。在原始模式下，**所有输入字符都会立即可用**，没有缓冲区或特殊字符的处理。
    
5. `tcflush()`: 这个函数用于 **刷新终端的输入或输出缓冲区**。可以通过指定参数 `TCIFLUSH` 来 **刷新输入缓冲区**，或者通过指定参数 `TCOFLUSH` 来 **刷新输出缓冲区**，还可以使用参数 `TCIOFLUSH` 来 **同时刷新输入和输出缓冲区**。
    

通过使用 `<termios.h>` 头文件提供的函数和数据类型，我们可以对终端进行更高级别的控制，如设置终端属性、控制终端输入输出的方式等。这对于需要实现特定终端行为的程序（如终端模拟器、串口通信等）非常有用。

### 3.2.1 `struct termios` 

`termios`结构体是一个用于 **存储终端属性** 的结构体，包含了与串行通信相关的各种设置和参数，描述终端的各种特性，如 **输入模式、输出模式、控制字符** 等。在这个结构体中，我们可以看到以下几个部分：

1. `c_iflag`：这个字段表示 **输入模式标志位**，用于控制终端 **如何处理输入字符**。例如，设置 `IGNBRK` 标志位可以忽略 BREAK 字符，设置 `IXON` 标志位可以启用 XON/XOFF 流控制等。
	
2. `c_oflag`：这个字段表示 **输出模式标志位**，用于控制终端 **如何处理输出字符**，如是否启用本地echo、是否启用超时等。例如，设置 `OPOST` 标志位可以启用输出映射和换行转换，设置 `ONLCR` 标志位可以将新行字符转换为回车加新行字符等。
	
3. `c_cflag`：这个字段表示 **控制模式标志位**，用于 **控制终端的硬件参数**。例如，**设置波特率、数据位数、停止位数、奇偶校验位**等。
	
4. `c_lflag`：这个字段表示 **本地模式标志位**，用于 **控制终端的行为**。例如，设置 `ICANON` 标志位可以启用规范模式，启用行编辑和 EOF 字符等。
	
5. `c_cc`：这个字段表示 **控制字符数组**，包含了一些 **特殊字符的定义**。例如，`c_cc[VINTR]` 表示中断字符，`c_cc[VEOF]` 表示输入结束字符等。

在这个结构体中，我们可以设置和获取与串行通信相关的各种参数，如波特率、数据位、停止位和奇偶校验等。通过修改`c_cflag`掩码，我们可以控制串行端口的这些参数。

### 3.2.2 `cfsetispeed ()` `cfsetospeed ()` 

`cfsetispeed` 和 `cfsetospeed` 是 termios 库中用于设置串口输入和输出波特率的函数。这两个函数通常与串口通信相关，用于确保发送方和接收方以相同的速率进行通信，以避免数据传输错误。

#### 1. `cfsetispeed(struct termios *termios_p, speed_t speed)` 

- 这个函数用于设置串口的 **输入波特率**。它接受两个参数，第一个参数是指向 `struct termios` 结构体的指针，第二个参数是一个表示波特率的整数值或宏定义。
- 例如，`cfsetispeed(&SerialPortSettings, B9600);` 将输入波特率设置为 9600 比特每秒。

#### 2. `cfsetospeed(struct termios *termios_p, speed_t speed)` 

- 这个函数用于设置串口的输出波特率。它接受两个参数，第一个参数是指向 `struct termios` 结构体的指针，第二个参数是一个表示波特率的整数值或宏定义。
- 例如，`cfsetospeed(&SerialPortSettings, B9600);` 将输出波特率设置为 9600 比特每秒。

在这两个函数中，`speed_t` 类型通常是一个整数类型，可以使用 **预定义的宏定义** 来表示标准的波特率，比如 `B9600`、`B115200` 等。这样可以使代码更易读，并且具有更好的可移植性。

> 常用的波特率宏定义为如下：
> `#define B0 0000000 /* hang up */`
> `#define B50 0000001`
> `#define B75 0000002`
> `#define B110 0000003`
> `#define B134 0000004`
> `#define B150 0000005`
> `#define B200 0000006`
> `#define B300 0000007`
> `#define B600 0000010`
> `#define B1200 0000011`
> `#define B1800 0000012`
> `#define B2400 0000013`
> `#define B4800 0000014`
> `#define B9600 0000015`
> `#define B19200 0000016`
> `#define B38400 0000017`

这两个函数配合结构体 `struct termios` 使用，通过操作该结构体中的字段来实现对串口的输入和输出波特率进行设置。这样就能确保发送方和接收方在相同的速率下进行通信，从而避免数据传输错误。

### 3.2.3 设置奇偶校验 `PARENB` 

`PARENB (Parity ENABLE)` 是用于 **设置奇偶校验** 的宏定义，用于表示 **「奇偶校验位使能」**，本质上是一个位掩码 `0000400` 。

**当 `PARENB` 位被设置为 `1` 时，奇偶校验功能会被启用**，发送方会在每个字符的末尾添加一个奇偶校验位，用于检测传输过程中的错误。接收方会根据奇偶校验位来验证数据的准确性，并在发现错误时进行纠正。

**而当 `PARENB` 位被设置为 `0` 时，奇偶校验功能会被禁用**，数据将以无校验的方式直接传输，不添加额外的校验位。

> [!attention] 
> 对于 `PARENB` 位来说，其掩码状态为： **其余位皆为 `0` ，而「奇偶校验使能位」(`PARENB` 位) 为 `1`** 。因此，开启和关闭奇偶校验的运算方法并不相同。

#### 1. 开启奇偶校验

``